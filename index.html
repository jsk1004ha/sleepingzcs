<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÏÇ¨Í∞ê Î™∞Îûò Ïû†ÏûêÍ∏∞</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --grid-color: rgba(255, 255, 255, 0.03);
            --desk-color: #1f1f1f;
            --desk-border: #333;
            --player-color: #00e5ff;
            --text-color: #ffffff;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Consolas', sans-serif;
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #viewport {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #world {
            position: absolute;
            width: 3000px;
            height: 2000px;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 60px 60px;
            transform-origin: 0 0;
            will-change: transform;
        }

        .desk {
            position: absolute;
            background-color: var(--desk-color);
            border: 1px solid var(--desk-border);
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.6);
            z-index: 5;
        }

        .character {
            position: absolute;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            transition: opacity 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            color: black;
            text-align: center;
        }

        .dir-pointer {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 3px;
            background: rgba(255,255,255,0.8);
            transform-origin: left center;
            transform: translateY(-50%);
        }

        #player {
            background: var(--player-color);
            border: 2px solid white;
            box-shadow: 0 0 15px var(--player-color);
        }

        /* ÏÇ¨Í∞ê Ïä§ÌÉÄÏùº */
        .enemy-1yr { background: #ff4757; border: 2px solid #ff6b81; box-shadow: 0 0 10px #ff4757; }
        .enemy-2yr { background: #ffa502; border: 2px solid #ffc048; box-shadow: 0 0 10px #ffa502; }
        .enemy-3yr { background: #2ed573; border: 2px solid #7bed9f; box-shadow: 0 0 10px #2ed573; }
        .enemy-king { background: #a55eea; border: 2px solid #d1d8e0; box-shadow: 0 0 20px #a55eea; width: 40px; height: 40px; }
        /* ÍµêÏû• Ïä§ÌÉÄÏùº */
        .enemy-principal { background: #000000; border: 2px solid #ffffff; box-shadow: 0 0 25px rgba(255,255,255,0.5); width: 44px; height: 44px; color: white !important; }

        .alert-icon {
            position: absolute;
            top: -40px;
            font-size: 28px;
            font-weight: bold;
            display: none;
            z-index: 30;
            text-shadow: 0 0 5px black;
            white-space: nowrap;
        }

        #vision-canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 10;
            pointer-events: none;
        }

        .zzz {
            position: absolute;
            color: var(--player-color);
            font-weight: bold;
            font-size: 20px;
            animation: floatUp 1s infinite linear;
            display: none;
            z-index: 40;
        }
        @keyframes floatUp {
            0% { transform: translate(0, 0) scale(0.8); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(15px, -30px) scale(1.2); opacity: 0; }
        }

        /* ÏÜåÏùå ÌååÎèô Ìö®Í≥º */
        .noise-ring {
            position: absolute;
            border: 2px solid rgba(0, 229, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: ripple 1s infinite ease-out;
            pointer-events: none;
            z-index: 15;
            display: none;
        }
        @keyframes ripple {
            0% { width: 0; height: 0; opacity: 1; }
            100% { width: 700px; height: 700px; opacity: 0; } /* Î∞òÍ≤Ω 350px * 2 */
        }

        .stunned { filter: grayscale(100%) brightness(0.5); }
        #stun-msg {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #a55eea;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 0 0 10px white;
            display: none;
            z-index: 150;
        }

        #mini-ui {
            position: fixed;
            top: 15px; left: 15px;
            z-index: 100;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
        #score-display { font-size: 24px; font-weight: bold; color: var(--player-color); }
        #combo-display { font-size: 16px; color: #ffcc00; opacity: 0; }
        #time-display { margin-top: 5px; color: #aaa; }

        #overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
        }
        h1 { font-size: 40px; margin-bottom: 10px; color: var(--player-color); }
        #end-msg { font-size: 28px; color: #ff4757; margin-bottom: 20px; font-weight: bold; }
        
        .btn-group { display: flex; flex-direction: column; gap: 15px; align-items: center; }
        button {
            padding: 15px 40px; font-size: 18px; background: transparent; color: var(--player-color);
            border: 2px solid var(--player-color); border-radius: 30px; cursor: pointer; font-weight: bold; transition: 0.2s;
        }
        button:hover { background: var(--player-color); color: #000; }
        
        .settings-area { margin-top: 20px; display: flex; align-items: center; gap: 10px; color: #aaa; font-size: 16px; }
        input[type="checkbox"] { width: 20px; height: 20px; accent-color: var(--player-color); }
        .hidden { display: none !important; }

        #mobile-controls {
            position: fixed; bottom: 30px; left: 0; width: 100%; height: 150px; z-index: 150;
            display: none; pointer-events: none;
        }
        #joystick-area {
            position: absolute; left: 40px; bottom: 20px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }
        #joystick-thumb {
            position: absolute; left: 50%; top: 50%; width: 50px; height: 50px;
            background: rgba(0, 229, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); box-shadow: 0 0 10px var(--player-color);
        }
        #sleep-btn {
            position: absolute; right: 40px; bottom: 30px; width: 90px; height: 90px;
            border-radius: 50%; background: rgba(165, 94, 234, 0.3); border: 2px solid #a55eea;
            color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
            pointer-events: auto; user-select: none; touch-action: none;
        }
        #sleep-btn:active { background: rgba(165, 94, 234, 0.8); }

        @media (max-width: 768px) { #mobile-controls { display: block; } }
    </style>
</head>
<body>

    <div id="viewport">
        <div id="world">
            <canvas id="vision-canvas"></canvas>
            <div id="player" class="character">
                <div class="dir-pointer"></div>
                <div class="zzz" id="zzz-particle">Zzz</div>
                <div class="noise-ring" id="noise-effect"></div>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <div id="joystick-area">
            <div id="joystick-thumb"></div>
        </div>
        <div id="sleep-btn">SLEEP</div>
    </div>

    <div id="stun-msg">Í∏∞Ï†à!!</div>

    <div id="mini-ui">
        <div id="score-display">0</div>
        <div id="combo-display">COMBO x1</div>
        <div id="time-display">ÏÉùÏ°¥ ÏãúÍ∞Ñ: 0s</div>
    </div>

    <div id="overlay">
        <h1 id="title-text">Stealth Sleep</h1>
        <div id="end-msg"></div>
        <p style="color:#aaa; margin-bottom:30px;">
            PC: WASD Ïù¥Îèô / SPACE Ïû†ÏûêÍ∏∞<br>
            Mobile: Ï°∞Ïù¥Ïä§Ìã± Ïù¥Îèô / Î≤ÑÌäº Ïû†ÏûêÍ∏∞<br>
            <span style="color:#ff4757; font-size:14px;">Ï£ºÏùò: Ïû†ÏùÑ ÏûêÎ©¥ ÏÜåÎ¶¨Í∞Ä ÎÇòÏÑú ÏÇ¨Í∞êÏù¥ Î™∞Î†§ÏòµÎãàÎã§!</span>
        </p>
        <div class="btn-group">
            <button id="start-btn">GAME START</button>
            <div class="settings-area">
                <input type="checkbox" id="mobile-toggle" checked>
                <label for="mobile-toggle">Î™®Î∞îÏùº Ïª®Ìä∏Î°§ ÌëúÏãú</label>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            worldW: 3000,
            worldH: 2000,
            playerSpeed: 3.0, 
            radius: 15,
            enemyBaseSpeed: 3.2,
            maxViewDist: 4000,
            noiseRadius: 350 // Ïû†Ïûò Îïå ÏÜåÎ¶¨Í∞Ä Îì§Î¶¨Îäî Î≤îÏúÑ
        };

        const WARDEN_TYPES = {
            '1yr': { name: "1ÌïôÎÖÑ ÏÇ¨Í∞ê", speed: 3.2, color: 'enemy-1yr', angle: 70, msg: "ÎÇ¥Í∞Ä Ïû†Íπ®ÏõåÏ£ºÎäî ÏÇ¨ÎûåÏù¥Ïïº?!!!!!" },
            '2yr': { name: "2ÌïôÎÖÑ ÏÇ¨Í∞ê", speed: 4.0, color: 'enemy-2yr', angle: 80, msg: "Ïù¥ÏÉàÎÅºÏïº!!!!!" },
            '3yr': { name: "3ÌïôÎÖÑ ÏÇ¨Í∞ê", speed: 2.6, color: 'enemy-3yr', angle: 90, msg: "ÏùºÎ£®ÏôÄ!!!!!", ability: 'pull' },
            'king':{ name: "ÏôïÏÇ¨Í∞ê", speed: 3.0, color: 'enemy-king', angle: 120, msg: "Ïù¥ ÏôïÏÇ¨Í∞êÎãòÏù¥... ÎãπÏã†ÏùÑ Ïû°ÏïòÏäµÎãàÎã§...!", ability: 'stun' },
            'principal': { name: "ÍµêÏû•", speed: 3.3, color: 'enemy-principal', angle: 100, msg: "Í≥µÎ∂ÄÌïòÏÑ∏Ïöî...!!", ability: 'omni' }
        };

        let state = {
            running: false,
            score: 0,
            combo: 1,
            sleepTimer: 0,
            gameTime: 0,
            keys: {},
            joystick: { x: 0, y: 0, active: false, id: null },
            player: { x: 0, y: 0, angle: 0, stunned: 0 },
            enemies: [],
            obstacles: [],
            animId: null
        };

        const els = {
            world: document.getElementById('world'),
            player: document.getElementById('player'),
            canvas: document.getElementById('vision-canvas'),
            ctx: document.getElementById('vision-canvas').getContext('2d'),
            score: document.getElementById('score-display'),
            combo: document.getElementById('combo-display'),
            time: document.getElementById('time-display'),
            zzz: document.getElementById('zzz-particle'),
            noise: document.getElementById('noise-effect'),
            stunMsg: document.getElementById('stun-msg'),
            overlay: document.getElementById('overlay'),
            endMsg: document.getElementById('end-msg'),
            btn: document.getElementById('start-btn'),
            mobileCtrl: document.getElementById('mobile-controls'),
            joyArea: document.getElementById('joystick-area'),
            joyThumb: document.getElementById('joystick-thumb'),
            sleepBtn: document.getElementById('sleep-btn'),
            mobileToggle: document.getElementById('mobile-toggle')
        };
        
        els.canvas.width = CONFIG.worldW;
        els.canvas.height = CONFIG.worldH;

        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        els.mobileToggle.checked = isMobile;
        updateMobileControlsVisibility();
        els.mobileToggle.addEventListener('change', updateMobileControlsVisibility);

        function updateMobileControlsVisibility() {
            if (els.mobileToggle.checked) {
                els.mobileCtrl.classList.remove('hidden');
                els.mobileCtrl.style.display = 'block';
            } else {
                els.mobileCtrl.classList.add('hidden');
                els.mobileCtrl.style.display = 'none';
            }
        }

        function generateMap() {
            document.querySelectorAll('.desk').forEach(e => e.remove());
            state.obstacles = [];

            const rows = 10, cols = 12;
            const startX = 200, startY = 200;
            const gapX = 240, gapY = 180;
            const w = 140, h = 90;

            for(let r=0; r<rows; r++){
                for(let c=0; c<cols; c++){
                    if(Math.random() > 0.88) continue; 
                    const x = startX + c * gapX;
                    const y = startY + r * gapY;
                    if (x > 1200 && x < 1800 && y > 800 && y < 1200) continue;

                    const div = document.createElement('div');
                    div.className = 'desk';
                    div.style.left = x + 'px'; div.style.top = y + 'px';
                    div.style.width = w + 'px'; div.style.height = h + 'px';
                    els.world.appendChild(div);
                    state.obstacles.push({ x, y, w, h });
                }
            }
        }

        function spawnEnemy(typeKey) {
            const type = WARDEN_TYPES[typeKey];
            let ex, ey;
            let safe = false;
            while(!safe) {
                ex = Math.random() * (CONFIG.worldW - 100) + 50;
                ey = Math.random() * (CONFIG.worldH - 100) + 50;
                const dist = Math.sqrt((ex-state.player.x)**2 + (ey-state.player.y)**2);
                if(dist > 800 && !checkCollide(ex, ey)) safe = true;
            }

            const el = document.createElement('div');
            el.className = `character ${type.color}`;
            if(typeKey === 'king') el.innerText = "Áéã"; 
            if(typeKey === 'principal') el.innerText = "Èï∑"; 
            
            const dir = document.createElement('div');
            dir.className = 'dir-pointer';
            el.appendChild(dir);

            const alert = document.createElement('div');
            alert.className = 'alert-icon';
            el.appendChild(alert);

            els.world.appendChild(el);

            state.enemies.push({
                el: el,
                alertEl: alert,
                type: typeKey,
                data: type,
                x: ex, y: ey, angle: 0,
                mode: 'PATROL',
                targetX: ex, targetY: ey,
                wait: 0,
                stuckCounter: 0,
                lastX: ex, lastY: ey,
                stunCooldown: 0,
                abilityTimer: 0 // ÍµêÏû•Ïö© ÌÉÄÏù¥Î®∏
            });
        }

        function checkCollide(x, y) {
            if(x < CONFIG.radius || x > CONFIG.worldW - CONFIG.radius || 
               y < CONFIG.radius || y > CONFIG.worldH - CONFIG.radius) return true;
            
            const padding = 8; 
            for(let o of state.obstacles) {
                if (x > o.x - CONFIG.radius + padding && x < o.x + o.w + CONFIG.radius - padding &&
                    y > o.y - CONFIG.radius + padding && y < o.y + o.h + CONFIG.radius - padding) {
                    return true;
                }
            }
            return false;
        }

        function findSafeSpawn() {
            const preferred = { x: 1500, y: 1000 };
            if (!checkCollide(preferred.x, preferred.y)) return preferred;
            return { x: 200, y: 200 };
        }

        function getIntersection(p0, p1, p2, p3) {
            const s1x = p1.x - p0.x, s1y = p1.y - p0.y;
            const s2x = p3.x - p2.x, s2y = p3.y - p2.y;
            const det = (-s2x * s1y + s1x * s2y);
            if (det === 0) return null;
            const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / det;
            const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / det;
            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) 
                return { x: p0.x + (t * s1x), y: p0.y + (t * s1y), param: t };
            return null;
        }

        function hasLineOfSight(start, end) {
            for(let o of state.obstacles) {
                const walls = [
                    {s:{x:o.x, y:o.y}, e:{x:o.x+o.w, y:o.y}},
                    {s:{x:o.x+o.w, y:o.y}, e:{x:o.x+o.w, y:o.y+o.h}},
                    {s:{x:o.x+o.w, y:o.y+o.h}, e:{x:o.x, y:o.y+o.h}},
                    {s:{x:o.x, y:o.y+o.h}, e:{x:o.x, y:o.y}}
                ];
                for(let w of walls) {
                    if(getIntersection(start, end, w.s, w.e)) return false;
                }
            }
            return true; 
        }

        function initJoystick() {
            const joy = els.joyArea;
            const thumb = els.joyThumb;
            const maxRadius = 35;

            const handleStart = (e) => {
                e.preventDefault();
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                state.joystick.id = touch.identifier;
                state.joystick.active = true;
                updateJoy(touch);
            };

            const handleMove = (e) => {
                e.preventDefault();
                if (!state.joystick.active) return;
                let touch = e;
                if (e.changedTouches) {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === state.joystick.id) {
                            touch = e.changedTouches[i];
                            break;
                        }
                    }
                }
                updateJoy(touch);
            };

            const handleEnd = (e) => {
                e.preventDefault();
                let isMyTouch = false;
                if (e.changedTouches) {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === state.joystick.id) isMyTouch = true;
                    }
                } else { isMyTouch = true; }

                if (isMyTouch) {
                    state.joystick.active = false;
                    state.joystick.x = 0; state.joystick.y = 0;
                    thumb.style.transform = `translate(-50%, -50%)`;
                }
            };

            const updateJoy = (touch) => {
                const rect = joy.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance > maxRadius) {
                    dx = (dx / distance) * maxRadius;
                    dy = (dy / distance) * maxRadius;
                }
                thumb.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                state.joystick.x = dx / maxRadius;
                state.joystick.y = dy / maxRadius;
            };

            joy.addEventListener('touchstart', handleStart, {passive: false});
            joy.addEventListener('touchmove', handleMove, {passive: false});
            joy.addEventListener('touchend', handleEnd, {passive: false});
            joy.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
        }

        function initSleepBtn() {
            const btn = els.sleepBtn;
            const start = (e) => { e.preventDefault(); state.keys['Space'] = true; btn.style.background = 'rgba(165, 94, 234, 0.8)'; };
            const end = (e) => { e.preventDefault(); state.keys['Space'] = false; btn.style.background = 'rgba(165, 94, 234, 0.3)'; };
            btn.addEventListener('touchstart', start, {passive: false});
            btn.addEventListener('touchend', end, {passive: false});
            btn.addEventListener('mousedown', start);
            btn.addEventListener('mouseup', end);
        }

        initJoystick();
        initSleepBtn();

        // --- ÏóÖÎç∞Ïù¥Ìä∏ Î°úÏßÅ ---
        function update() {
            state.gameTime++;
            if (state.gameTime % 60 === 0) {
                const sec = Math.floor(state.gameTime / 60);
                els.time.innerText = `ÏÉùÏ°¥ ÏãúÍ∞Ñ: ${sec}s`;
                
                // Í∏∞Ï°¥ Ïä§Ìè∞ Î°úÏßÅ
                if (sec === 20) spawnEnemy('2yr');
                if (sec === 40) spawnEnemy('3yr');
                if (sec === 60) spawnEnemy('king');
                
                // ÍµêÏû• Ïä§Ìè∞ (90Ï¥à)
                if (sec === 90) spawnEnemy('principal');

                // Î¨¥Ìïú ÎûúÎç§ Ïä§Ìè∞ (90Ï¥à Ïù¥ÌõÑ 30Ï¥àÎßàÎã§)
                if (sec > 90 && (sec - 90) % 30 === 0) {
                    const types = ['1yr', '2yr', '3yr', 'king', 'principal'];
                    const randomType = types[Math.floor(Math.random() * types.length)];
                    spawnEnemy(randomType);
                    
                    const noti = document.createElement('div');
                    noti.innerText = "ÏßÄÏõêÍµ∞ ÎèÑÏ∞©!";
                    noti.style.position = 'fixed'; noti.style.top = '20%'; noti.style.left='50%';
                    noti.style.transform = 'translate(-50%, -50%)'; noti.style.color = 'red';
                    noti.style.fontWeight = 'bold'; noti.style.fontSize = '24px';
                    noti.style.textShadow = '0 0 5px black';
                    document.body.appendChild(noti);
                    setTimeout(() => noti.remove(), 2000);
                }
            }

            // ÌîåÎ†àÏù¥Ïñ¥
            if (state.player.stunned > 0) {
                state.player.stunned--;
                els.player.classList.add('stunned');
                els.stunMsg.style.display = 'block';
            } else {
                els.player.classList.remove('stunned');
                els.stunMsg.style.display = 'none';

                if(state.keys['Space']) {
                    // Ïû†ÏûêÎäî Ï§ë
                    state.sleepTimer++;
                    if(state.sleepTimer % 60 === 0 && state.combo < 10) state.combo++;
                    state.score += Math.floor(state.combo * 5);
                    els.zzz.style.display = 'block';
                    //els.noise.style.display = 'block'; // ÏÜåÏùå Ìö®Í≥º

                    // --- ÏÜåÏùå Î°úÏßÅ (Noise Mechanic) ---
                    // ÏùºÏ†ï Î∞òÍ≤Ω ÎÇ¥Ïùò ÏÇ¨Í∞êÏùÄ Î≤Ω ÎÑàÎ®∏ÏóêÏÑúÎèÑ ÏÜåÎ¶¨Î•º Îì£Í≥† Ï´ìÏïÑÏò¥
                    state.enemies.forEach(e => {
                        const dist = Math.sqrt((e.x - state.player.x)**2 + (e.y - state.player.y)**2);
                        if (dist < CONFIG.noiseRadius) {
                            e.mode = 'CHASE';
                            e.targetX = state.player.x; 
                            e.targetY = state.player.y;
                            e.alertEl.innerText = '‚ô™'; // ÏÜåÎ¶¨ ÏïÑÏù¥ÏΩò
                            e.alertEl.style.display = 'block';
                            e.alertEl.style.color = '#00e5ff';
                        }
                    });

                } else {
                    state.sleepTimer = 0;
                    state.combo = 1;
                    els.zzz.style.display = 'none';
                    els.noise.style.display = 'none';
                    
                    let dx = 0, dy = 0;
                    if(state.keys['ArrowUp'] || state.keys['KeyW']) dy -= 1;
                    if(state.keys['ArrowDown'] || state.keys['KeyS']) dy += 1;
                    if(state.keys['ArrowLeft'] || state.keys['KeyA']) dx -= 1;
                    if(state.keys['ArrowRight'] || state.keys['KeyD']) dx += 1;

                    if (state.joystick.active) {
                        dx = state.joystick.x;
                        dy = state.joystick.y;
                    }

                    if(dx !== 0 || dy !== 0) {
                        const len = Math.sqrt(dx*dx + dy*dy);
                        const moveSpeed = (len > 1 ? 1 : len) * CONFIG.playerSpeed;
                        const ndx = (dx/len) * moveSpeed;
                        const ndy = (dy/len) * moveSpeed;

                        if(!checkCollide(state.player.x + ndx, state.player.y)) state.player.x += ndx;
                        if(!checkCollide(state.player.x, state.player.y + ndy)) state.player.y += ndy;
                        state.player.angle = Math.atan2(ndy, ndx);
                    }
                }
            }

            // ÏÇ¨Í∞êÎì§ ÏóÖÎç∞Ïù¥Ìä∏
            state.enemies.forEach(e => {
                const p = state.player;
                const dist = Math.sqrt((e.x - p.x)**2 + (e.y - p.y)**2);

                // 1. ÏãúÏïº Ï≤¥ÌÅ¨ (Î¨¥Ìïú Í±∞Î¶¨)
                let canSee = false;
                let angleToP = Math.atan2(p.y - e.y, p.x - e.x) - e.angle;
                while(angleToP <= -Math.PI) angleToP += Math.PI*2;
                while(angleToP > Math.PI) angleToP -= Math.PI*2;
                
                if(Math.abs(angleToP) < (e.data.angle * Math.PI / 180) / 2) {
                    if(hasLineOfSight(e, p)) canSee = true;
                }

                // ÌäπÏàò Îä•Î†• Ï≤¥ÌÅ¨
                if (e.stunCooldown > 0) e.stunCooldown--;
                
                // ÏôïÏÇ¨Í∞ê: Í∏∞Ï†à
                if (e.type === 'king' && dist < 150 && !p.stunned && e.stunCooldown <= 0) {
                    p.stunned = 120; e.stunCooldown = 180;
                }
                // 3ÌïôÎÖÑ: ÎÅåÏñ¥ÎãπÍ∏∞Í∏∞
                if (e.type === '3yr' && canSee) {
                    const pullAngle = Math.atan2(e.y - p.y, e.x - p.x);
                    const pullSpeed = 1.5;
                    if (!checkCollide(p.x + Math.cos(pullAngle)*pullSpeed, p.y)) p.x += Math.cos(pullAngle)*pullSpeed;
                    if (!checkCollide(p.x, p.y + Math.sin(pullAngle)*pullSpeed)) p.y += Math.sin(pullAngle)*pullSpeed;
                }
                // ÍµêÏû•: 20Ï¥àÎßàÎã§ ÏúÑÏπò ÌååÏïÖ (Global Scan)
                if (e.type === 'principal') {
                    e.abilityTimer++;
                    if (e.abilityTimer > 1200) { // 20Ï¥à (60fps Í∏∞Ï§Ä)
                        e.mode = 'CHASE';
                        e.targetX = p.x; e.targetY = p.y;
                        e.abilityTimer = 0;
                        e.alertEl.innerText = 'üëÅÔ∏è'; // Í∞êÏßÄ ÏïÑÏù¥ÏΩò
                        e.alertEl.style.display = 'block';
                        e.alertEl.style.color = 'white';
                    }
                }

                // AI ÏÉÅÌÉú
                if (canSee) {
                    e.mode = 'CHASE';
                    e.targetX = p.x; e.targetY = p.y;
                    e.wait = 0;
                    e.alertEl.style.display = 'block'; e.alertEl.innerText = '!'; e.alertEl.style.color = '#ff2a6d';
                } else if (e.mode === 'CHASE') {
                    e.mode = 'SEARCH';
                    e.wait = 120;
                    if (e.alertEl.innerText === '!') { // ÏÜåÎ¶¨ÎÇò ÍµêÏû• Îä•Î†•Ïù¥ ÏïÑÎãê ÎïåÎßå ?Î°ú Î≥ÄÍ≤Ω
                        e.alertEl.innerText = '?'; e.alertEl.style.color = '#ffcc00';
                    }
                }

                let tx = e.targetX, ty = e.targetY;
                let speed = e.data.speed;

                // ÏàúÏ∞∞ Î°úÏßÅ
                if (e.mode === 'PATROL') {
                    speed *= 0.5;
                    const d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                    if (d < 20) {
                        e.targetX = Math.random() * CONFIG.worldW;
                        e.targetY = Math.random() * CONFIG.worldH;
                        e.targetX = Math.max(20, Math.min(CONFIG.worldW - 20, e.targetX));
                        e.targetY = Math.max(20, Math.min(CONFIG.worldH - 20, e.targetY));
                    }
                } else if (e.mode === 'SEARCH') {
                    const d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                    if (d < 10) {
                        if (e.wait > 0) { e.wait--; e.angle += 0.05; return; }
                        else { e.mode = 'PATROL'; e.alertEl.style.display = 'none'; }
                    }
                }

                // Ïù¥Îèô
                const dx = tx - e.x;
                const dy = ty - e.y;
                const dLen = Math.sqrt(dx*dx + dy*dy);

                if (dLen > 1) {
                    const mx = (dx / dLen) * speed;
                    const my = (dy / dLen) * speed;

                    let targetAngle = Math.atan2(my, mx);
                    let diff = targetAngle - e.angle;
                    while(diff <= -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;
                    e.angle += diff * 0.1;

                    let movedX = false;
                    let movedY = false;
                    if (!checkCollide(e.x + mx, e.y)) { e.x += mx; movedX = true; }
                    if (!checkCollide(e.x, e.y + my)) { e.y += my; movedY = true; }

                    if (!movedX && !movedY) {
                        const escapeAngles = [45, -45, 90, -90];
                        for (let ang of escapeAngles) {
                            const rad = (e.angle + ang * Math.PI / 180);
                            const sx = Math.cos(rad) * speed;
                            const sy = Math.sin(rad) * speed;
                            if (!checkCollide(e.x + sx, e.y + sy)) {
                                e.x += sx; e.y += sy; break;
                            }
                        }
                    }
                }

                // ÎÅºÏûÑ ÌÉàÏ∂ú
                const moveDist = Math.sqrt((e.x - e.lastX)**2 + (e.y - e.lastY)**2);
                if (moveDist < 0.5) {
                    e.stuckCounter++;
                    if (e.stuckCounter > 30) {
                        e.mode = 'PATROL';
                        e.targetX = Math.random() * CONFIG.worldW;
                        e.targetY = Math.random() * CONFIG.worldH;
                        if (e.stuckCounter > 60) {
                            for(let i=0; i<8; i++) {
                                const ang = Math.random() * Math.PI * 2;
                                const nx = e.x + Math.cos(ang) * 20;
                                const ny = e.y + Math.sin(ang) * 20;
                                if(!checkCollide(nx, ny)) { e.x = nx; e.y = ny; break; }
                            }
                            e.stuckCounter = 0;
                        }
                    }
                } else { e.stuckCounter = 0; }
                
                e.lastX = e.x; e.lastY = e.y;

                if (dist < CONFIG.radius * 2) gameOver(e);
            });
        }

        function draw() {
            const cx = window.innerWidth/2 - state.player.x;
            const cy = window.innerHeight/2 - state.player.y;
            els.world.style.transform = `translate3d(${cx}px, ${cy}px, 0)`;

            els.player.style.transform = `translate(${state.player.x}px, ${state.player.y}px) rotate(${state.player.angle}rad)`;

            state.enemies.forEach(e => {
                e.el.style.transform = `translate(${e.x}px, ${e.y}px) rotate(${e.angle}rad)`;
                const visible = hasLineOfSight(state.player, e);
                e.el.style.opacity = visible ? 1 : 0;
                e.visible = visible;
            });

            els.score.innerText = state.score.toLocaleString();
            els.combo.innerText = `COMBO x${state.combo}`;
            els.combo.style.opacity = state.combo > 1 ? 1 : 0;

            const ctx = els.ctx;
            ctx.clearRect(0, 0, CONFIG.worldW, CONFIG.worldH);

            const mapBorders = [
                {s:{x:0, y:0}, e:{x:CONFIG.worldW, y:0}},
                {s:{x:CONFIG.worldW, y:0}, e:{x:CONFIG.worldW, y:CONFIG.worldH}},
                {s:{x:CONFIG.worldW, y:CONFIG.worldH}, e:{x:0, y:CONFIG.worldH}},
                {s:{x:0, y:CONFIG.worldH}, e:{x:0, y:0}}
            ];

            state.enemies.forEach(e => {
                if(!e.visible) return;

                const rays = 30;
                const viewAngle = e.data.angle * Math.PI / 180;
                const startAngle = e.angle - viewAngle/2;
                const step = viewAngle / rays;

                if (e.type === 'king') ctx.fillStyle = "rgba(165, 94, 234, 0.3)";
                else if (e.type === 'principal') ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
                else ctx.fillStyle = "rgba(255, 71, 87, 0.3)";

                ctx.beginPath();
                ctx.moveTo(e.x, e.y);

                for(let i=0; i<=rays; i++) {
                    const ang = startAngle + step * i;
                    const rayEnd = { x: e.x + Math.cos(ang)*CONFIG.maxViewDist, y: e.y + Math.sin(ang)*CONFIG.maxViewDist };
                    
                    let closest = rayEnd;
                    let minT = 1.0;

                    for(let o of state.obstacles) {
                        const walls = [
                            {s:{x:o.x, y:o.y}, e:{x:o.x+o.w, y:o.y}},
                            {s:{x:o.x+o.w, y:o.y}, e:{x:o.x+o.w, y:o.y+o.h}},
                            {s:{x:o.x+o.w, y:o.y+o.h}, e:{x:o.x, y:o.y+o.h}},
                            {s:{x:o.x, y:o.y+o.h}, e:{x:o.x, y:o.y}}
                        ];
                        for(let w of walls) {
                            const isect = getIntersection(e, rayEnd, w.s, w.e);
                            if(isect && isect.param < minT) { minT = isect.param; closest = isect; }
                        }
                    }

                    for(let w of mapBorders) {
                        const isect = getIntersection(e, rayEnd, w.s, w.e);
                        if(isect && isect.param < minT) { minT = isect.param; closest = isect; }
                    }

                    ctx.lineTo(closest.x, closest.y);
                }
                ctx.closePath();
                ctx.fill();
            });
        }

        function loop() {
            if(!state.running) return;
            update();
            draw();
            state.animId = requestAnimationFrame(loop);
        }

        function gameOver(killer) {
            state.running = false;
            cancelAnimationFrame(state.animId);
            els.overlay.classList.remove('hidden');
            document.getElementById('title-text').innerText = "Í≤ÄÍ±∞Îê®";
            els.endMsg.innerText = `"${killer.data.msg}"`;
            els.endMsg.style.color = killer.type === 'king' ? '#a55eea' : (killer.type === 'principal' ? '#ffffff' : '#ff4757');
            els.btn.innerText = "Îã§Ïãú ÎèÑÏ†Ñ";
        }

        els.btn.addEventListener('click', () => {
            if(state.animId) cancelAnimationFrame(state.animId);
            state.enemies.forEach(e => e.el.remove());
            state.enemies = [];
            generateMap();
            state.running = true;
            state.score = 0;
            state.combo = 1;
            state.gameTime = 0;
            const spawn = findSafeSpawn();
            state.player = { x: spawn.x, y: spawn.y, angle: 0, stunned: 0 };
            spawnEnemy('1yr');
            els.overlay.classList.add('hidden');
            loop();
        });

        window.addEventListener('keydown', e => state.keys[e.code] = true);
        window.addEventListener('keyup', e => state.keys[e.code] = false);
    </script>
</body>
</html>
