<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>사감 몰래 잠자기</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --grid-color: rgba(255, 255, 255, 0.03);
            --desk-color: #1f1f1f;
            --desk-border: #333;
            --player-color: #00e5ff;
            --text-color: #ffffff;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Consolas', sans-serif;
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #viewport {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #world {
            position: absolute;
            width: 3000px;
            height: 2000px;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 60px 60px;
            transform-origin: 0 0;
            will-change: transform;
        }

        .desk {
            position: absolute;
            background-color: var(--desk-color);
            border: 1px solid var(--desk-border);
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.6);
            z-index: 5;
        }

        .character {
            position: absolute;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            transition: opacity 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            color: black;
            text-align: center;
        }

        .dir-pointer {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 3px;
            background: rgba(255,255,255,0.8);
            transform-origin: left center;
            transform: translateY(-50%);
        }

        #player {
            background: var(--player-color);
            border: 2px solid white;
            box-shadow: 0 0 15px var(--player-color);
        }

        /* 사감 스타일 */
        .enemy-1yr { background: #ff4757; border: 2px solid #ff6b81; box-shadow: 0 0 10px #ff4757; }
        .enemy-2yr { background: #ffa502; border: 2px solid #ffc048; box-shadow: 0 0 10px #ffa502; }
        .enemy-3yr { background: #2ed573; border: 2px solid #7bed9f; box-shadow: 0 0 10px #2ed573; }
        .enemy-king { background: #a55eea; border: 2px solid #d1d8e0; box-shadow: 0 0 20px #a55eea; width: 40px; height: 40px; }

        /* 상태 아이콘 */
        .alert-icon {
            position: absolute;
            top: -40px;
            font-size: 28px;
            font-weight: bold;
            display: none;
            z-index: 30;
            text-shadow: 0 0 5px black;
        }

        #vision-canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 10;
            pointer-events: none;
        }

        .zzz {
            position: absolute;
            color: var(--player-color);
            font-weight: bold;
            font-size: 20px;
            animation: floatUp 1s infinite linear;
            display: none;
            z-index: 40;
        }
        @keyframes floatUp {
            0% { transform: translate(0, 0) scale(0.8); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(15px, -30px) scale(1.2); opacity: 0; }
        }

        /* 기절 효과 */
        .stunned {
            filter: grayscale(100%) brightness(0.5);
        }
        #stun-msg {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #a55eea;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 0 0 10px white;
            display: none;
            z-index: 150;
        }

        #mini-ui {
            position: fixed;
            top: 15px; left: 15px;
            z-index: 100;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
        #score-display { font-size: 24px; font-weight: bold; color: var(--player-color); }
        #combo-display { font-size: 16px; color: #ffcc00; opacity: 0; }
        #time-display { margin-top: 5px; color: #aaa; }

        #overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
        }
        h1 { font-size: 40px; margin-bottom: 10px; color: var(--player-color); }
        #end-msg { font-size: 28px; color: #ff4757; margin-bottom: 20px; font-weight: bold; }
        
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        button {
            padding: 15px 40px;
            font-size: 18px;
            background: transparent;
            color: var(--player-color);
            border: 2px solid var(--player-color);
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover { background: var(--player-color); color: #000; }
        
        .settings-area {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #aaa;
            font-size: 16px;
        }
        input[type="checkbox"] {
            width: 20px; height: 20px;
            accent-color: var(--player-color);
        }

        .hidden { display: none !important; }

        /* --- Mobile Controls --- */
        #mobile-controls {
            position: fixed;
            bottom: 30px;
            left: 0;
            width: 100%;
            height: 150px;
            z-index: 150;
            display: none;
            pointer-events: none;
        }

        #joystick-area {
            position: absolute;
            left: 40px;
            bottom: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        #joystick-thumb {
            position: absolute;
            left: 50%; top: 50%;
            width: 50px; height: 50px;
            background: rgba(0, 229, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px var(--player-color);
        }

        #sleep-btn {
            position: absolute;
            right: 40px;
            bottom: 30px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: rgba(165, 94, 234, 0.3);
            border: 2px solid #a55eea;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            user-select: none;
            touch-action: none;
        }
        #sleep-btn:active {
            background: rgba(165, 94, 234, 0.8);
        }

        @media (max-width: 768px) {
            #mobile-controls { display: block; }
        }
    </style>
</head>
<body>

    <div id="viewport">
        <div id="world">
            <canvas id="vision-canvas"></canvas>
            <div id="player" class="character">
                <div class="dir-pointer"></div>
                <div class="zzz" id="zzz-particle">Zzz</div>
            </div>
            <!-- 적들은 JS로 생성 -->
        </div>
    </div>

    <!-- 모바일 컨트롤 -->
    <div id="mobile-controls">
        <div id="joystick-area">
            <div id="joystick-thumb"></div>
        </div>
        <div id="sleep-btn">SLEEP</div>
    </div>

    <div id="stun-msg">기절!!</div>

    <div id="mini-ui">
        <div id="score-display">0</div>
        <div id="combo-display">COMBO x1</div>
        <div id="time-display">생존 시간: 0s</div>
    </div>

    <div id="overlay">
        <h1 id="title-text">Stealth Sleep</h1>
        <div id="end-msg"></div>
        <p style="color:#aaa; margin-bottom:30px;">
            PC: WASD 이동 / SPACE 잠자기<br>
            Mobile: 조이스틱 이동 / 버튼 잠자기
        </p>
        
        <div class="btn-group">
            <button id="start-btn">GAME START</button>
            <div class="settings-area">
                <input type="checkbox" id="mobile-toggle" checked>
                <label for="mobile-toggle">모바일 컨트롤 표시</label>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            worldW: 3000,
            worldH: 2000,
            playerSpeed: 3.0, 
            radius: 15,
            enemyBaseSpeed: 3.2 
        };

        const WARDEN_TYPES = {
            '1yr': { name: "1학년 사감", speed: 3.2, color: 'enemy-1yr', view: 450, angle: 70, msg: "내가 잠깨워주는 사람이야?!!!!!" },
            '2yr': { name: "2학년 사감", speed: 4.0, color: 'enemy-2yr', view: 500, angle: 80, msg: "이새끼야!!!!!" },
            '3yr': { name: "3학년 사감", speed: 2.6, color: 'enemy-3yr', view: 550, angle: 90, msg: "일루와!!!!!", ability: 'pull' },
            'king':{ name: "왕사감", speed: 3.0, color: 'enemy-king', view: 800, angle: 120, msg: "이 왕사감이... 당신을 잡았습니다...!", ability: 'stun' }
        };

        let state = {
            running: false,
            score: 0,
            combo: 1,
            sleepTimer: 0,
            gameTime: 0,
            keys: {},
            joystick: { x: 0, y: 0, active: false, id: null },
            player: { x: 0, y: 0, angle: 0, stunned: 0 },
            enemies: [],
            obstacles: [],
            animId: null
        };

        const els = {
            world: document.getElementById('world'),
            player: document.getElementById('player'),
            canvas: document.getElementById('vision-canvas'),
            ctx: document.getElementById('vision-canvas').getContext('2d'),
            score: document.getElementById('score-display'),
            combo: document.getElementById('combo-display'),
            time: document.getElementById('time-display'),
            zzz: document.getElementById('zzz-particle'),
            stunMsg: document.getElementById('stun-msg'),
            overlay: document.getElementById('overlay'),
            endMsg: document.getElementById('end-msg'),
            btn: document.getElementById('start-btn'),
            mobileCtrl: document.getElementById('mobile-controls'),
            joyArea: document.getElementById('joystick-area'),
            joyThumb: document.getElementById('joystick-thumb'),
            sleepBtn: document.getElementById('sleep-btn'),
            mobileToggle: document.getElementById('mobile-toggle')
        };
        
        els.canvas.width = CONFIG.worldW;
        els.canvas.height = CONFIG.worldH;

        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        els.mobileToggle.checked = isMobile;
        updateMobileControlsVisibility();

        els.mobileToggle.addEventListener('change', updateMobileControlsVisibility);

        function updateMobileControlsVisibility() {
            if (els.mobileToggle.checked) {
                els.mobileCtrl.classList.remove('hidden');
                els.mobileCtrl.style.display = 'block';
            } else {
                els.mobileCtrl.classList.add('hidden');
                els.mobileCtrl.style.display = 'none';
            }
        }

        // --- 맵 생성 ---
        function generateMap() {
            document.querySelectorAll('.desk').forEach(e => e.remove());
            state.obstacles = [];

            const rows = 10, cols = 12;
            const startX = 200, startY = 200;
            const gapX = 240, gapY = 180;
            const w = 140, h = 90;

            for(let r=0; r<rows; r++){
                for(let c=0; c<cols; c++){
                    if(Math.random() > 0.88) continue; 
                    const x = startX + c * gapX;
                    const y = startY + r * gapY;
                    
                    if (x > 1200 && x < 1800 && y > 800 && y < 1200) continue;

                    const div = document.createElement('div');
                    div.className = 'desk';
                    div.style.left = x + 'px'; div.style.top = y + 'px';
                    div.style.width = w + 'px'; div.style.height = h + 'px';
                    els.world.appendChild(div);
                    state.obstacles.push({ x, y, w, h });
                }
            }
        }

        // --- 사감 생성 ---
        function spawnEnemy(typeKey) {
            const type = WARDEN_TYPES[typeKey];
            let ex, ey;
            let safe = false;
            while(!safe) {
                ex = Math.random() * (CONFIG.worldW - 100) + 50;
                ey = Math.random() * (CONFIG.worldH - 100) + 50;
                const dist = Math.sqrt((ex-state.player.x)**2 + (ey-state.player.y)**2);
                if(dist > 800 && !checkCollide(ex, ey)) safe = true;
            }

            const el = document.createElement('div');
            el.className = `character ${type.color}`;
            if(typeKey === 'king') el.innerText = "王"; 
            
            const dir = document.createElement('div');
            dir.className = 'dir-pointer';
            el.appendChild(dir);

            const alert = document.createElement('div');
            alert.className = 'alert-icon';
            el.appendChild(alert);

            els.world.appendChild(el);

            state.enemies.push({
                el: el,
                alertEl: alert,
                type: typeKey,
                data: type,
                x: ex, y: ey, angle: 0,
                mode: 'PATROL',
                targetX: ex, targetY: ey,
                wait: 0,
                stuckCounter: 0, // 끼임 감지용 카운터
                lastX: ex, lastY: ey, // 이전 위치 저장
                stunCooldown: 0
            });
        }

        // --- 물리 및 유틸 ---
        function checkCollide(x, y) {
            if(x < CONFIG.radius || x > CONFIG.worldW - CONFIG.radius || 
               y < CONFIG.radius || y > CONFIG.worldH - CONFIG.radius) return true;
            
            // 끼임 방지를 위해 충돌 박스를 조금 더 여유있게 계산
            const padding = 8; 
            for(let o of state.obstacles) {
                if (x > o.x - CONFIG.radius + padding && x < o.x + o.w + CONFIG.radius - padding &&
                    y > o.y - CONFIG.radius + padding && y < o.y + o.h + CONFIG.radius - padding) {
                    return true;
                }
            }
            return false;
        }

        function findSafeSpawn() {
            const preferred = { x: 1500, y: 1000 };
            if (!checkCollide(preferred.x, preferred.y)) return preferred;
            return { x: 200, y: 200 };
        }

        function getIntersection(p0, p1, p2, p3) {
            const s1x = p1.x - p0.x, s1y = p1.y - p0.y;
            const s2x = p3.x - p2.x, s2y = p3.y - p2.y;
            const det = (-s2x * s1y + s1x * s2y);
            if (det === 0) return null;
            const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / det;
            const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / det;
            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) 
                return { x: p0.x + (t * s1x), y: p0.y + (t * s1y), param: t };
            return null;
        }

        function hasLineOfSight(start, end) {
            for(let o of state.obstacles) {
                const walls = [
                    {s:{x:o.x, y:o.y}, e:{x:o.x+o.w, y:o.y}},
                    {s:{x:o.x+o.w, y:o.y}, e:{x:o.x+o.w, y:o.y+o.h}},
                    {s:{x:o.x+o.w, y:o.y+o.h}, e:{x:o.x, y:o.y+o.h}},
                    {s:{x:o.x, y:o.y+o.h}, e:{x:o.x, y:o.y}}
                ];
                for(let w of walls) {
                    if(getIntersection(start, end, w.s, w.e)) return false;
                }
            }
            return true;
        }

        function initJoystick() {
            const joy = els.joyArea;
            const thumb = els.joyThumb;
            const maxRadius = 35;

            const handleStart = (e) => {
                e.preventDefault();
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                state.joystick.id = touch.identifier;
                state.joystick.active = true;
                updateJoy(touch);
            };

            const handleMove = (e) => {
                e.preventDefault();
                if (!state.joystick.active) return;
                let touch = e;
                if (e.changedTouches) {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === state.joystick.id) {
                            touch = e.changedTouches[i];
                            break;
                        }
                    }
                }
                updateJoy(touch);
            };

            const handleEnd = (e) => {
                e.preventDefault();
                let isMyTouch = false;
                if (e.changedTouches) {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === state.joystick.id) isMyTouch = true;
                    }
                } else {
                    isMyTouch = true;
                }

                if (isMyTouch) {
                    state.joystick.active = false;
                    state.joystick.x = 0;
                    state.joystick.y = 0;
                    thumb.style.transform = `translate(-50%, -50%)`;
                }
            };

            const updateJoy = (touch) => {
                const rect = joy.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx*dx + dy*dy);

                if (distance > maxRadius) {
                    dx = (dx / distance) * maxRadius;
                    dy = (dy / distance) * maxRadius;
                }

                thumb.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                state.joystick.x = dx / maxRadius;
                state.joystick.y = dy / maxRadius;
            };

            joy.addEventListener('touchstart', handleStart, {passive: false});
            joy.addEventListener('touchmove', handleMove, {passive: false});
            joy.addEventListener('touchend', handleEnd, {passive: false});
            joy.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
        }

        function initSleepBtn() {
            const btn = els.sleepBtn;
            const start = (e) => { e.preventDefault(); state.keys['Space'] = true; btn.style.background = 'rgba(165, 94, 234, 0.8)'; };
            const end = (e) => { e.preventDefault(); state.keys['Space'] = false; btn.style.background = 'rgba(165, 94, 234, 0.3)'; };
            btn.addEventListener('touchstart', start, {passive: false});
            btn.addEventListener('touchend', end, {passive: false});
            btn.addEventListener('mousedown', start);
            btn.addEventListener('mouseup', end);
        }

        initJoystick();
        initSleepBtn();

        // --- 업데이트 로직 ---
        function update() {
            state.gameTime++;
            if (state.gameTime % 60 === 0) {
                const sec = Math.floor(state.gameTime / 60);
                els.time.innerText = `생존 시간: ${sec}s`;
                if (sec === 20) spawnEnemy('2yr');
                if (sec === 40) spawnEnemy('3yr');
                if (sec === 60) spawnEnemy('king');
            }

            // 플레이어
            if (state.player.stunned > 0) {
                state.player.stunned--;
                els.player.classList.add('stunned');
                els.stunMsg.style.display = 'block';
            } else {
                els.player.classList.remove('stunned');
                els.stunMsg.style.display = 'none';

                if(state.keys['Space']) {
                    state.sleepTimer++;
                    if(state.sleepTimer % 60 === 0 && state.combo < 10) state.combo++;
                    state.score += Math.floor(state.combo * 5);
                    els.zzz.style.display = 'block';
                } else {
                    state.sleepTimer = 0;
                    state.combo = 1;
                    els.zzz.style.display = 'none';
                    
                    let dx = 0, dy = 0;
                    if(state.keys['ArrowUp'] || state.keys['KeyW']) dy -= 1;
                    if(state.keys['ArrowDown'] || state.keys['KeyS']) dy += 1;
                    if(state.keys['ArrowLeft'] || state.keys['KeyA']) dx -= 1;
                    if(state.keys['ArrowRight'] || state.keys['KeyD']) dx += 1;

                    if (state.joystick.active) {
                        dx = state.joystick.x;
                        dy = state.joystick.y;
                    }

                    if(dx !== 0 || dy !== 0) {
                        const len = Math.sqrt(dx*dx + dy*dy);
                        const moveSpeed = (len > 1 ? 1 : len) * CONFIG.playerSpeed;
                        const ndx = (dx/len) * moveSpeed;
                        const ndy = (dy/len) * moveSpeed;

                        if(!checkCollide(state.player.x + ndx, state.player.y)) state.player.x += ndx;
                        if(!checkCollide(state.player.x, state.player.y + ndy)) state.player.y += ndy;
                        
                        state.player.angle = Math.atan2(ndy, ndx);
                    }
                }
            }

            // 사감들 업데이트 (스마트 이동 로직 적용)
            state.enemies.forEach(e => {
                const p = state.player;
                const dist = Math.sqrt((e.x - p.x)**2 + (e.y - p.y)**2);

                // 시야 체크
                let canSee = false;
                if(dist < e.data.view) {
                    let angleToP = Math.atan2(p.y - e.y, p.x - e.x) - e.angle;
                    while(angleToP <= -Math.PI) angleToP += Math.PI*2;
                    while(angleToP > Math.PI) angleToP -= Math.PI*2;
                    if(Math.abs(angleToP) < (e.data.angle * Math.PI / 180) / 2) {
                        if(hasLineOfSight(e, p)) canSee = true;
                    }
                }

                // 특수 능력
                if (e.stunCooldown > 0) e.stunCooldown--;
                if (e.type === 'king' && dist < 150 && !p.stunned && e.stunCooldown <= 0) {
                    p.stunned = 120; e.stunCooldown = 180;
                }
                if (e.type === '3yr' && canSee) {
                    const pullAngle = Math.atan2(e.y - p.y, e.x - p.x);
                    const pullSpeed = 1.5;
                    if (!checkCollide(p.x + Math.cos(pullAngle)*pullSpeed, p.y)) p.x += Math.cos(pullAngle)*pullSpeed;
                    if (!checkCollide(p.x, p.y + Math.sin(pullAngle)*pullSpeed)) p.y += Math.sin(pullAngle)*pullSpeed;
                }

                // AI 상태 변경
                if (canSee) {
                    e.mode = 'CHASE';
                    e.targetX = p.x; e.targetY = p.y;
                    e.wait = 0;
                    e.alertEl.style.display = 'block';
                    e.alertEl.innerText = '!';
                    e.alertEl.style.color = '#ff2a6d';
                } else if (e.mode === 'CHASE') {
                    e.mode = 'SEARCH';
                    e.wait = 120;
                    e.alertEl.innerText = '?';
                    e.alertEl.style.color = '#ffcc00';
                }

                let tx = e.targetX, ty = e.targetY;
                let speed = e.data.speed;

                // 순찰/수색 로직
                if (e.mode === 'PATROL') {
                    speed *= 0.5;
                    const d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                    if (d < 20) {
                        e.targetX = Math.random() * (CONFIG.worldW - 100) + 50;
                        e.targetY = Math.random() * (CONFIG.worldH - 100) + 50;
                    }
                } else if (e.mode === 'SEARCH') {
                    const d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                    if (d < 10) {
                        if (e.wait > 0) {
                            e.wait--; e.angle += 0.05; return;
                        } else {
                            e.mode = 'PATROL';
                            e.alertEl.style.display = 'none';
                        }
                    }
                }

                // --- 이동 및 충돌 해결 (핵심 개선 부분) ---
                const dx = tx - e.x;
                const dy = ty - e.y;
                const dLen = Math.sqrt(dx*dx + dy*dy);

                if (dLen > 1) {
                    const mx = (dx / dLen) * speed;
                    const my = (dy / dLen) * speed;

                    // 부드러운 회전
                    let targetAngle = Math.atan2(my, mx);
                    let diff = targetAngle - e.angle;
                    while(diff <= -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;
                    e.angle += diff * 0.1;

                    // 1. 기본 이동 시도 (X, Y 독립 체크 - 미끄러짐 구현)
                    let movedX = false;
                    let movedY = false;
                    
                    if (!checkCollide(e.x + mx, e.y)) { e.x += mx; movedX = true; }
                    if (!checkCollide(e.x, e.y + my)) { e.y += my; movedY = true; }

                    // 2. 완전히 막혔을 때 (코너/벽) - 회피 기동(Steering)
                    if (!movedX && !movedY) {
                        // 좌우 45도, 90도 각도로 탈출구 탐색
                        const escapeAngles = [45, -45, 90, -90];
                        let escaped = false;
                        for (let ang of escapeAngles) {
                            const rad = (e.angle + ang * Math.PI / 180);
                            const sx = Math.cos(rad) * speed;
                            const sy = Math.sin(rad) * speed;
                            if (!checkCollide(e.x + sx, e.y + sy)) {
                                e.x += sx; e.y += sy;
                                escaped = true;
                                break;
                            }
                        }
                    }
                }

                // 3. 강제 탈출 (Unstuck) - 실제로 움직이지 못하고 있으면 감지
                const moveDist = Math.sqrt((e.x - e.lastX)**2 + (e.y - e.lastY)**2);
                if (moveDist < 0.5) {
                    e.stuckCounter++;
                    // 약 0.5초 이상 끼어있으면
                    if (e.stuckCounter > 30) {
                        // 1단계: 목표 지점 변경 (순찰 모드로 전환)
                        e.mode = 'PATROL';
                        e.targetX = Math.random() * (CONFIG.worldW - 100) + 50;
                        e.targetY = Math.random() * (CONFIG.worldH - 100) + 50;
                        
                        // 2단계: 심각하게 끼인 경우 약간 텔레포트 (벽 밖으로 튕겨내기)
                        if (e.stuckCounter > 60) {
                            // 랜덤 방향으로 살짝 이동 시도
                            for(let i=0; i<8; i++) {
                                const ang = Math.random() * Math.PI * 2;
                                const nx = e.x + Math.cos(ang) * 20;
                                const ny = e.y + Math.sin(ang) * 20;
                                if(!checkCollide(nx, ny)) {
                                    e.x = nx; e.y = ny;
                                    break;
                                }
                            }
                            e.stuckCounter = 0;
                        }
                    }
                } else {
                    e.stuckCounter = 0;
                }
                
                // 위치 저장
                e.lastX = e.x;
                e.lastY = e.y;

                if (dist < CONFIG.radius * 2) {
                    gameOver(e);
                }
            });
        }

        function draw() {
            const cx = window.innerWidth/2 - state.player.x;
            const cy = window.innerHeight/2 - state.player.y;
            els.world.style.transform = `translate3d(${cx}px, ${cy}px, 0)`;

            els.player.style.transform = `translate(${state.player.x}px, ${state.player.y}px) rotate(${state.player.angle}rad)`;

            state.enemies.forEach(e => {
                e.el.style.transform = `translate(${e.x}px, ${e.y}px) rotate(${e.angle}rad)`;
                const visible = hasLineOfSight(state.player, e);
                e.el.style.opacity = visible ? 1 : 0;
                e.visible = visible;
            });

            els.score.innerText = state.score.toLocaleString();
            els.combo.innerText = `COMBO x${state.combo}`;
            els.combo.style.opacity = state.combo > 1 ? 1 : 0;

            const ctx = els.ctx;
            ctx.clearRect(0, 0, CONFIG.worldW, CONFIG.worldH);

            state.enemies.forEach(e => {
                if(!e.visible) return;

                const rays = 30;
                const viewAngle = e.data.angle * Math.PI / 180;
                const startAngle = e.angle - viewAngle/2;
                const step = viewAngle / rays;

                ctx.fillStyle = e.type === 'king' ? "rgba(165, 94, 234, 0.3)" : "rgba(255, 71, 87, 0.3)";
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);

                for(let i=0; i<=rays; i++) {
                    const ang = startAngle + step * i;
                    const rayEnd = { x: e.x + Math.cos(ang)*e.data.view, y: e.y + Math.sin(ang)*e.data.view };
                    
                    let closest = rayEnd;
                    let minT = 1.0;

                    for(let o of state.obstacles) {
                        const walls = [
                            {s:{x:o.x, y:o.y}, e:{x:o.x+o.w, y:o.y}},
                            {s:{x:o.x+o.w, y:o.y}, e:{x:o.x+o.w, y:o.y+o.h}},
                            {s:{x:o.x+o.w, y:o.y+o.h}, e:{x:o.x, y:o.y+o.h}},
                            {s:{x:o.x, y:o.y+o.h}, e:{x:o.x, y:o.y}}
                        ];
                        for(let w of walls) {
                            const isect = getIntersection(e, rayEnd, w.s, w.e);
                            if(isect && isect.param < minT) { minT = isect.param; closest = isect; }
                        }
                    }
                    ctx.lineTo(closest.x, closest.y);
                }
                ctx.closePath();
                ctx.fill();
            });
        }

        function loop() {
            if(!state.running) return;
            update();
            draw();
            state.animId = requestAnimationFrame(loop);
        }

        function gameOver(killer) {
            state.running = false;
            cancelAnimationFrame(state.animId);
            els.overlay.classList.remove('hidden');
            document.getElementById('title-text').innerText = "검거됨";
            els.endMsg.innerText = `"${killer.data.msg}"`;
            els.endMsg.style.color = killer.type === 'king' ? '#a55eea' : '#ff4757';
            els.btn.innerText = "다시 도전";
        }

        els.btn.addEventListener('click', () => {
            if(state.animId) cancelAnimationFrame(state.animId);
            
            state.enemies.forEach(e => e.el.remove());
            state.enemies = [];

            generateMap();
            state.running = true;
            state.score = 0;
            state.combo = 1;
            state.gameTime = 0;
            const spawn = findSafeSpawn();
            state.player = { x: spawn.x, y: spawn.y, angle: 0, stunned: 0 };
            
            spawnEnemy('1yr');

            els.overlay.classList.add('hidden');
            loop();
        });

        window.addEventListener('keydown', e => state.keys[e.code] = true);
        window.addEventListener('keyup', e => state.keys[e.code] = false);
    </script>
</body>
</html>
