<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stealth Sleep: Warden's Nightmare</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --grid-color: rgba(255, 255, 255, 0.03);
            --desk-color: #1f1f1f;
            --desk-border: #333;
            --player-color: #00e5ff;
            --text-color: #ffffff;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Consolas', sans-serif;
            color: var(--text-color);
            user-select: none;
        }

        #viewport {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #world {
            position: absolute;
            width: 3000px;
            height: 2000px;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 60px 60px;
            transform-origin: 0 0;
            will-change: transform;
        }

        .desk {
            position: absolute;
            background-color: var(--desk-color);
            border: 1px solid var(--desk-border);
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.6);
            z-index: 5;
        }

        .character {
            position: absolute;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            transition: opacity 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            color: black;
            text-align: center;
        }

        .dir-pointer {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 3px;
            background: rgba(255,255,255,0.8);
            transform-origin: left center;
            transform: translateY(-50%);
        }

        #player {
            background: var(--player-color);
            border: 2px solid white;
            box-shadow: 0 0 15px var(--player-color);
        }

        /* 사감 스타일 */
        .enemy-1yr { background: #ff4757; border: 2px solid #ff6b81; box-shadow: 0 0 10px #ff4757; }
        .enemy-2yr { background: #ffa502; border: 2px solid #ffc048; box-shadow: 0 0 10px #ffa502; }
        .enemy-3yr { background: #2ed573; border: 2px solid #7bed9f; box-shadow: 0 0 10px #2ed573; }
        .enemy-king { background: #a55eea; border: 2px solid #d1d8e0; box-shadow: 0 0 20px #a55eea; width: 40px; height: 40px; }

        /* 상태 아이콘 */
        .alert-icon {
            position: absolute;
            top: -40px;
            font-size: 28px;
            font-weight: bold;
            display: none;
            z-index: 30;
            text-shadow: 0 0 5px black;
        }

        #vision-canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 10;
            pointer-events: none;
        }

        .zzz {
            position: absolute;
            color: var(--player-color);
            font-weight: bold;
            font-size: 20px;
            animation: floatUp 1s infinite linear;
            display: none;
            z-index: 40;
        }
        @keyframes floatUp {
            0% { transform: translate(0, 0) scale(0.8); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(15px, -30px) scale(1.2); opacity: 0; }
        }

        /* 기절 효과 */
        .stunned {
            filter: grayscale(100%) brightness(0.5);
        }
        #stun-msg {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #a55eea;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 0 0 10px white;
            display: none;
            z-index: 150;
        }

        #mini-ui {
            position: fixed;
            top: 15px; left: 15px;
            z-index: 100;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
        #score-display { font-size: 24px; font-weight: bold; color: var(--player-color); }
        #combo-display { font-size: 16px; color: #ffcc00; opacity: 0; }
        #time-display { margin-top: 5px; color: #aaa; }

        #overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
        }
        h1 { font-size: 40px; margin-bottom: 10px; color: var(--player-color); }
        #end-msg { font-size: 28px; color: #ff4757; margin-bottom: 20px; font-weight: bold; }
        button {
            padding: 15px 40px;
            font-size: 18px;
            background: transparent;
            color: var(--player-color);
            border: 2px solid var(--player-color);
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background: var(--player-color); color: #000; }
        .hidden { display: none !important; }

        /* Mobile controls */
        #mobile-controls {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 400;
            display: flex;
            gap: 18px;
            align-items: center;
            pointer-events: none; /* enable only children */
        }
        #mobile-joystick {
            width: 110px;
            height: 110px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            pointer-events: auto;
            position: relative;
            touch-action: none;
            box-shadow: 0 6px 18px rgba(0,0,0,0.6);
        }
        #mobile-thumb {
            position: absolute;
            left: 50%; top: 50%;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            background: rgba(0,230,255,0.9);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 6px 16px rgba(0,0,0,0.5), 0 0 12px rgba(0,230,255,0.25);
        }
        .mobile-sleep-btn {
            width: 92px; height: 92px;
            border-radius: 50%; border: none;
            background: linear-gradient(135deg, rgba(0,230,255,0.06), rgba(165,94,234,0.06));
            color: var(--player-color);
            font-weight: bold;
            pointer-events: auto;
            box-shadow: 0 6px 18px rgba(0,0,0,0.6), 0 0 18px rgba(165,94,234,0.08);
            backdrop-filter: blur(4px);
            font-size: 16px;
        }

        /* Hide mobile controls on large screens; will be shown via JS when needed */
        @media (min-width: 801px) {
            #mobile-controls { display: none !important; }
        }
    </style>
</head>
<body>

    <div id="viewport">
        <div id="world">
            <canvas id="vision-canvas"></canvas>
            <div id="player" class="character">
                <div class="dir-pointer"></div>
                <div class="zzz" id="zzz-particle">Zzz</div>
            </div>
            <!-- 적들은 JS로 생성 -->
        </div>
    </div>

    <div id="stun-msg">기절!!</div>

    <div id="mini-ui">
        <div id="score-display">0</div>
        <div id="combo-display">COMBO x1</div>
        <div id="time-display">생존 시간: 0s</div>
    </div>

    <div id="overlay">
        <h1 id="title-text">Stealth Sleep</h1>
        <div id="end-msg"></div>
        <p style="color:#aaa; margin-bottom:30px;">
            시간이 지날수록 더 강력한 사감이 등장합니다.<br>
            왕사감을 만나면 기절할 수 있으니 주의하세요!
        </p>
        <button id="start-btn">GAME START</button>
    </div>

    <!-- 모바일 컨트롤: 조이스틱 + 잠자기 버튼 -->
    <div id="mobile-controls" class="hidden">
        <div id="mobile-joystick">
            <div id="mobile-thumb"></div>
        </div>
        <button id="mobile-sleep" class="mobile-sleep-btn">잠자기</button>
    </div>

    <script>
        // --- 설정 (속도 감소 반영) ---
        const CONFIG = {
            worldW: 3000,
            worldH: 2000,
            playerSpeed: 3.0, // 속도 감소
            radius: 15,
            enemyBaseSpeed: 3.2 // 사감 기본 속도 (플레이어보다 약간 빠름)
        };

        // --- 사감 데이터 ---
        const WARDEN_TYPES = {
            '1yr': { name: "1학년 사감", speed: 3.2, color: 'enemy-1yr', view: 450, angle: 70, msg: "내가 잠깨워주는 사람이야?!!!!!" },
            '2yr': { name: "2학년 사감", speed: 4.0, color: 'enemy-2yr', view: 500, angle: 80, msg: "이새끼야!!!!!" },
            '3yr': { name: "3학년 사감", speed: 2.6, color: 'enemy-3yr', view: 550, angle: 90, msg: "일루와!!!!!", ability: 'pull' },
            'king':{ name: "왕사감", speed: 3.0, color: 'enemy-king', view: 800, angle: 120, msg: "이 왕사감이... 당신을 잡았습니다...!", ability: 'stun' }
        };

        // --- 상태 변수 ---
        let state = {
            running: false,
            score: 0,
            combo: 1,
            sleepTimer: 0,
            gameTime: 0,
            spawnTimer: 0,
            keys: {},
            player: { x: 0, y: 0, angle: 0, stunned: 0 },
            enemies: [], // 사감 배열
            obstacles: [],
            animId: null
        };

        // --- DOM ---
        const els = {
            world: document.getElementById('world'),
            player: document.getElementById('player'),
            canvas: document.getElementById('vision-canvas'),
            ctx: document.getElementById('vision-canvas').getContext('2d'),
            score: document.getElementById('score-display'),
            combo: document.getElementById('combo-display'),
            time: document.getElementById('time-display'),
            zzz: document.getElementById('zzz-particle'),
            stunMsg: document.getElementById('stun-msg'),
            overlay: document.getElementById('overlay'),
            endMsg: document.getElementById('end-msg'),
            btn: document.getElementById('start-btn')
            ,
            // mobile controls (created in DOM below)
            mobileControls: null,
            mobileJoystick: null,
            mobileThumb: null,
            mobileSleepBtn: null
        };
        
        els.canvas.width = CONFIG.worldW;
        els.canvas.height = CONFIG.worldH;

        // --- mobile / touch detection ---
        function isMobileMode() {
            return ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.innerWidth <= 800;
        }

        // initialize mobile controls references and touch state
        state.touch = { active: false, dx: 0, dy: 0, baseX: 0, baseY: 0, radius: 44 };

        function initMobileControls() {
            els.mobileControls = document.getElementById('mobile-controls');
            els.mobileJoystick = document.getElementById('mobile-joystick');
            els.mobileThumb = document.getElementById('mobile-thumb');
            els.mobileSleepBtn = document.getElementById('mobile-sleep');

            if (!els.mobileControls) return;

            // show only on mobile mode
            if (isMobileMode()) els.mobileControls.classList.remove('hidden');
            else els.mobileControls.classList.add('hidden');

            // joystick pointer handlers
            function onStart(ev) {
                ev.preventDefault();
                const rect = els.mobileJoystick.getBoundingClientRect();
                // base center
                state.touch.baseX = rect.left + rect.width/2;
                state.touch.baseY = rect.top + rect.height/2;
                state.touch.active = true;
                // handle initial move
                onMove(ev);
            }

            function onMove(ev) {
                if (!state.touch.active) return;
                const p = ev.touches ? ev.touches[0] : ev; // support touch and pointer
                const vx = p.clientX - state.touch.baseX;
                const vy = p.clientY - state.touch.baseY;
                const max = Math.min(els.mobileJoystick.clientWidth, els.mobileJoystick.clientHeight)/2 - 10;
                let nx = vx, ny = vy;
                const len = Math.sqrt(nx*nx + ny*ny) || 1;
                if (len > max) { nx = nx / len * max; ny = ny / len * max; }
                // normalized -1..1
                state.touch.dx = nx / max;
                state.touch.dy = ny / max;
                // move thumb
                els.mobileThumb.style.transform = `translate(${nx}px, ${ny}px)`;
            }

            function onEnd(ev) {
                ev.preventDefault && ev.preventDefault();
                state.touch.active = false;
                state.touch.dx = 0; state.touch.dy = 0;
                els.mobileThumb.style.transform = `translate(-50%, -50%)`;
            }

            // pointer events (works for touch and mouse)
            els.mobileJoystick.addEventListener('pointerdown', onStart);
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', onEnd);

            // also support touch events just in case
            els.mobileJoystick.addEventListener('touchstart', onStart, {passive:false});
            els.mobileJoystick.addEventListener('touchmove', onMove, {passive:false});
            els.mobileJoystick.addEventListener('touchend', onEnd);

            // sleep button handlers (act as space key)
            els.mobileSleepBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); state.keys['Space']=true; });
            els.mobileSleepBtn.addEventListener('pointerup', e=>{ e.preventDefault(); state.keys['Space']=false; });
            els.mobileSleepBtn.addEventListener('touchstart', e=>{ e.preventDefault(); state.keys['Space']=true; }, {passive:false});
            els.mobileSleepBtn.addEventListener('touchend', e=>{ e.preventDefault(); state.keys['Space']=false; });

            // resize handler to toggle mobile UI
            window.addEventListener('resize', () => {
                if (isMobileMode()) els.mobileControls.classList.remove('hidden');
                else els.mobileControls.classList.add('hidden');
            });
        }

        // init mobile controls after DOM
        initMobileControls();

        // --- 맵 생성 ---
        function generateMap() {
            document.querySelectorAll('.desk').forEach(e => e.remove());
            state.obstacles = [];

            const rows = 10, cols = 12;
            const startX = 200, startY = 200;
            const gapX = 240, gapY = 180;
            const w = 140, h = 90;

            for(let r=0; r<rows; r++){
                for(let c=0; c<cols; c++){
                    if(Math.random() > 0.88) continue; // 길 만들기
                    const x = startX + c * gapX;
                    const y = startY + r * gapY;
                    
                    // 중앙 안전지대
                    if (x > 1200 && x < 1800 && y > 800 && y < 1200) continue;

                    const div = document.createElement('div');
                    div.className = 'desk';
                    div.style.left = x + 'px'; div.style.top = y + 'px';
                    div.style.width = w + 'px'; div.style.height = h + 'px';
                    els.world.appendChild(div);
                    state.obstacles.push({ x, y, w, h });
                }
            }
        }

        // --- 사감 생성 ---
        function spawnEnemy(typeKey) {
            const type = WARDEN_TYPES[typeKey];
            // 플레이어와 먼 곳에서 스폰
            let ex, ey;
            let safe = false;
            while(!safe) {
                ex = Math.random() * (CONFIG.worldW - 100) + 50;
                ey = Math.random() * (CONFIG.worldH - 100) + 50;
                const dist = Math.sqrt((ex-state.player.x)**2 + (ey-state.player.y)**2);
                if(dist > 800 && !checkCollide(ex, ey)) safe = true;
            }

            const el = document.createElement('div');
            el.className = `character ${type.color}`;
            // 왕사감은 텍스트 표시
            if(typeKey === 'king') el.innerText = "王"; 
            
            const dir = document.createElement('div');
            dir.className = 'dir-pointer';
            el.appendChild(dir);

            const alert = document.createElement('div');
            alert.className = 'alert-icon';
            el.appendChild(alert);

            els.world.appendChild(el);

            state.enemies.push({
                el: el,
                alertEl: alert,
                type: typeKey,
                data: type,
                x: ex, y: ey, angle: 0,
                mode: 'PATROL',
                targetX: ex, targetY: ey,
                wait: 0,
                stuckCounter: 0,
                stunCooldown: 0,
                lastX: ex, lastY: ey
            });
        }

        // --- 물리 및 유틸 ---
        function checkCollide(x, y) {
            // 맵 경계
            if(x < CONFIG.radius || x > CONFIG.worldW - CONFIG.radius || 
               y < CONFIG.radius || y > CONFIG.worldH - CONFIG.radius) return true;
            
            // 책상 충돌 (약간의 여유를 둬서 끼임 방지)
            const padding = 5; 
            for(let o of state.obstacles) {
                if (x > o.x - CONFIG.radius + padding && x < o.x + o.w + CONFIG.radius - padding &&
                    y > o.y - CONFIG.radius + padding && y < o.y + o.h + CONFIG.radius - padding) {
                    return true;
                }
            }
            return false;
        }

        // --- 플레이어 안전 스폰 지점 찾기 ---
        function findSafeSpawn() {
            // 우선 중앙 안전지대 시도
            const preferred = { x: 1500, y: 1000 };
            if (!checkCollide(preferred.x, preferred.y)) return preferred;

            // 몇 가지 후보 지점(모서리와 랜덤)을 시험
            const candidates = [
                { x: 1500, y: 1000 },
                { x: 200, y: 200 },
                { x: CONFIG.worldW - 200, y: 200 },
                { x: 200, y: CONFIG.worldH - 200 },
                { x: CONFIG.worldW - 200, y: CONFIG.worldH - 200 }
            ];

            for (let c of candidates) {
                if (!checkCollide(c.x, c.y)) return c;
            }

            // 랜덤 시도 (성공할 때까지 제한된 횟수)
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * (CONFIG.worldW - 200) + 100;
                const y = Math.random() * (CONFIG.worldH - 200) + 100;
                if (!checkCollide(x, y)) return { x, y };
            }

            // 실패 시 마지막 안전값 반환
            return { x: Math.min(Math.max(1500, CONFIG.radius), CONFIG.worldW - CONFIG.radius),
                     y: Math.min(Math.max(1000, CONFIG.radius), CONFIG.worldH - CONFIG.radius) };
        }

        // 선분 교차 (시야용)
        function getIntersection(p0, p1, p2, p3) {
            const s1x = p1.x - p0.x, s1y = p1.y - p0.y;
            const s2x = p3.x - p2.x, s2y = p3.y - p2.y;
            const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / (-s2x * s1y + s1x * s2y);
            const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / (-s2x * s1y + s1x * s2y);
            // 분모가 0인 경우(평행) 처리 필요하지만 간단히 생략
            const det = (-s2x * s1y + s1x * s2y);
            if (det === 0) return null;

            const s_val = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / det;
            const t_val = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / det;

            if (s_val >= 0 && s_val <= 1 && t_val >= 0 && t_val <= 1) 
                return { x: p0.x + (t_val * s1x), y: p0.y + (t_val * s1y), param: t_val };
            return null;
        }

        function hasLineOfSight(start, end) {
            for(let o of state.obstacles) {
                const walls = [
                    {s:{x:o.x, y:o.y}, e:{x:o.x+o.w, y:o.y}},
                    {s:{x:o.x+o.w, y:o.y}, e:{x:o.x+o.w, y:o.y+o.h}},
                    {s:{x:o.x+o.w, y:o.y+o.h}, e:{x:o.x, y:o.y+o.h}},
                    {s:{x:o.x, y:o.y+o.h}, e:{x:o.x, y:o.y}}
                ];
                for(let w of walls) {
                    if(getIntersection(start, end, w.s, w.e)) return false;
                }
            }
            return true;
        }

        // --- 업데이트 로직 ---
        function update() {
            // 시간 관리 및 스폰
            state.gameTime++;
            if (state.gameTime % 60 === 0) { // 1초마다
                const sec = Math.floor(state.gameTime / 60);
                els.time.innerText = `생존 시간: ${sec}s`;
                
                // 스폰 로직
                if (sec === 20) spawnEnemy('2yr');
                if (sec === 40) spawnEnemy('3yr');
                if (sec === 60) spawnEnemy('king');
            }

            // 플레이어
            if (state.player.stunned > 0) {
                state.player.stunned--;
                els.player.classList.add('stunned');
                els.stunMsg.style.display = 'block';
            } else {
                els.player.classList.remove('stunned');
                els.stunMsg.style.display = 'none';

                if(state.keys['Space']) {
                    state.sleepTimer++;
                    if(state.sleepTimer % 60 === 0 && state.combo < 10) state.combo++;
                    state.score += Math.floor(state.combo * 5);
                    els.zzz.style.display = 'block';
                } else {
                    state.sleepTimer = 0;
                    state.combo = 1;
                    els.zzz.style.display = 'none';
                    
                    // Movement: keyboard or mobile touch joystick
                    let dx = 0, dy = 0;
                    if (state.touch && state.touch.active) {
                        dx = state.touch.dx;
                        dy = state.touch.dy;
                    } else {
                        if(state.keys['ArrowUp'] || state.keys['KeyW']) dy -= 1;
                        if(state.keys['ArrowDown'] || state.keys['KeyS']) dy += 1;
                        if(state.keys['ArrowLeft'] || state.keys['KeyA']) dx -= 1;
                        if(state.keys['ArrowRight'] || state.keys['KeyD']) dx += 1;
                    }

                    if(dx !== 0 || dy !== 0) {
                        const len = Math.sqrt(dx*dx + dy*dy);
                        dx = (dx/len) * CONFIG.playerSpeed;
                        dy = (dy/len) * CONFIG.playerSpeed;

                        // 충돌 버그 수정: X축, Y축 독립적으로 체크
                        if(!checkCollide(state.player.x + dx, state.player.y)) state.player.x += dx;
                        if(!checkCollide(state.player.x, state.player.y + dy)) state.player.y += dy;
                        
                        state.player.angle = Math.atan2(dy, dx);
                    }
                }
            }

            // 사감들 업데이트
            state.enemies.forEach(e => {
                const p = state.player;
                const dist = Math.sqrt((e.x - p.x)**2 + (e.y - p.y)**2);

                // QUICK UNSTICK: if enemy somehow is overlapping a desk/wall, try small nudges
                if (checkCollide(e.x, e.y)) {
                    let freed = false;
                    const nudgeDist = CONFIG.radius * 2 + 6;
                    for (let a = 0; a < 12; a++) {
                        const ang = Math.random() * Math.PI * 2;
                        const nx = e.x + Math.cos(ang) * nudgeDist;
                        const ny = e.y + Math.sin(ang) * nudgeDist;
                        if (!checkCollide(nx, ny)) { e.x = nx; e.y = ny; e.stuckCounter = 0; freed = true; break; }
                    }
                    if (!freed) {
                        // fallback: give this enemy a new distant waypoint
                        e.targetX = Math.random() * (CONFIG.worldW - 200) + 100;
                        e.targetY = Math.random() * (CONFIG.worldH - 200) + 100;
                        e.mode = 'PATROL';
                        e.stuckCounter = 0;
                    }
                }

                // 1. 시야 체크
                let canSee = false;
                if(dist < e.data.view) {
                    let angleToP = Math.atan2(p.y - e.y, p.x - e.x) - e.angle;
                    while(angleToP <= -Math.PI) angleToP += Math.PI*2;
                    while(angleToP > Math.PI) angleToP -= Math.PI*2;
                    
                    if(Math.abs(angleToP) < (e.data.angle * Math.PI / 180) / 2) {
                        if(hasLineOfSight(e, p)) canSee = true;
                    }
                }

                // 2. 특수 능력 (안 보여도 거리 내면 발동 - 왕사감)
                // - add per-king cooldown to prevent immediate re-stun when player stays in range
                if (e.stunCooldown > 0) e.stunCooldown--;
                if (e.type === 'king' && dist < 150 && !p.stunned && e.stunCooldown <= 0) {
                    p.stunned = 120; // 2초 기절
                    e.stunCooldown = 180; // 3초 재기절 쿨다운
                }

                // 3. 특수 능력 (보여야 발동 - 3학년)
                if (e.type === '3yr' && canSee) {
                    // 플레이어를 끌어당김
                    const pullAngle = Math.atan2(e.y - p.y, e.x - p.x);
                    const pullSpeed = 1.5;
                    if (!checkCollide(p.x + Math.cos(pullAngle)*pullSpeed, p.y)) p.x += Math.cos(pullAngle)*pullSpeed;
                    if (!checkCollide(p.x, p.y + Math.sin(pullAngle)*pullSpeed)) p.y += Math.sin(pullAngle)*pullSpeed;
                }

                // 4. AI 상태 머신
                if (canSee) {
                    e.mode = 'CHASE';
                    e.targetX = p.x; e.targetY = p.y;
                    e.wait = 0;
                    e.alertEl.style.display = 'block';
                    e.alertEl.innerText = '!';
                    e.alertEl.style.color = '#ff2a6d';
                } else if (e.mode === 'CHASE') {
                    // 추격 중 시야 놓침 -> 마지막 위치로 이동(SEARCH)
                    e.mode = 'SEARCH';
                    e.wait = 120; // 2초간 두리번
                    e.alertEl.innerText = '?';
                    e.alertEl.style.color = '#ffcc00';
                }

                // 5. 이동 로직
                let tx = e.targetX, ty = e.targetY;
                let speed = e.data.speed;

                if (e.mode === 'PATROL') {
                    speed *= 0.5; // 순찰은 천천히
                    const d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                    if (d < 20) {
                        // 랜덤 웨이포인트
                        e.targetX = Math.random() * (CONFIG.worldW - 100) + 50;
                        e.targetY = Math.random() * (CONFIG.worldH - 100) + 50;
                    }
                } else if (e.mode === 'SEARCH') {
                    const d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                    if (d < 10) {
                        if (e.wait > 0) {
                            e.wait--;
                            e.angle += 0.05; // 두리번
                            return;
                        } else {
                            e.mode = 'PATROL';
                            e.alertEl.style.display = 'none';
                        }
                    }
                }

                // remember previous position to detect tiny/no movement
                const prevX = e.x, prevY = e.y;

                // 실제 이동
                const dx = tx - e.x;
                const dy = ty - e.y;
                const dLen = Math.sqrt(dx*dx + dy*dy);

                if (dLen > 1) {
                    const mx = (dx / dLen) * speed;
                    const my = (dy / dLen) * speed;

                    // 부드러운 회전
                    let targetAngle = Math.atan2(my, mx);
                    let diff = targetAngle - e.angle;
                    while(diff <= -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;
                    e.angle += diff * 0.1;

                    // 개선된 이동 및 충돌 처리
                    // - 먼저 X/Y 각각 검사하여 가능한 축만 이동
                    // - 둘 다 막히면 주변 각도로 더 넓게 시도
                    // - 계속 막히면 teleport fallback
                    let movedX = false, movedY = false;
                    const canMoveX = !checkCollide(e.x + mx, e.y);
                    const canMoveY = !checkCollide(e.x, e.y + my);

                    if (canMoveX) { e.x += mx; movedX = true; }
                    if (canMoveY) { e.y += my; movedY = true; }

                    if (!movedX && !movedY) {
                        // Stronger bounce steering: try multiple angles (45-120 degrees)
                        let steered = false;
                        const bounceAngles = [45, 60, 90, 120, 135]; // try these offsets in order
                        
                        for (let degOffset of bounceAngles) {
                            if (steered) break;
                            const rad = degOffset * Math.PI / 180;
                            for (let sign of [1, -1]) {
                                const ang = targetAngle + rad * sign;
                                const sx = Math.cos(ang) * speed;
                                const sy = Math.sin(ang) * speed;
                                if (!checkCollide(e.x + sx, e.y + sy)) {
                                    e.x += sx; e.y += sy; steered = true; break;
                                }
                                // also try partial movement on each axis
                                if (!checkCollide(e.x + sx, e.y)) { e.x += sx; steered = true; break; }
                                if (!checkCollide(e.x, e.y + sy)) { e.y += sy; steered = true; break; }
                            }
                        }

                        // if bounce steering didn't work, try full 360 sweep
                        if (!steered) {
                            const trySteps = 24; // finer sweep
                            for (let s = 0; s <= trySteps && !steered; s++) {
                                const off = (s / trySteps) * Math.PI * 2; // 0..2PI (full circle)
                                const sx2 = Math.cos(off) * speed * 0.9;
                                const sy2 = Math.sin(off) * speed * 0.9;
                                if (!checkCollide(e.x + sx2, e.y + sy2)) { e.x += sx2; e.y += sy2; steered = true; break; }
                                if (!checkCollide(e.x + sx2, e.y)) { e.x += sx2; steered = true; break; }
                                if (!checkCollide(e.x, e.y + sy2)) { e.y += sy2; steered = true; break; }
                            }
                        }

                        if (!steered) {
                            // no escape this frame; increment stuck counter
                            e.stuckCounter = (e.stuckCounter || 0) + 1;
                            if (e.stuckCounter > 15) { // reduced threshold for faster escape
                                // try random teleport away from player
                                let teleported = false;
                                for (let t = 0; t < 40; t++) {
                                    const rx = Math.random() * (CONFIG.worldW - 200) + 100;
                                    const ry = Math.random() * (CONFIG.worldH - 200) + 100;
                                    const dd = Math.sqrt((rx - state.player.x)**2 + (ry - state.player.y)**2);
                                    if (dd > 200 && !checkCollide(rx, ry)) { e.x = rx; e.y = ry; teleported = true; break; }
                                }
                                if (!teleported) {
                                    e.targetX = Math.random() * (CONFIG.worldW - 100) + 50;
                                    e.targetY = Math.random() * (CONFIG.worldH - 100) + 50;
                                }
                                e.mode = 'PATROL';
                                e.stuckCounter = 0;
                            }
                        } else {
                            e.stuckCounter = 0;
                        }
                    } else {
                        // normal movement
                        e.stuckCounter = 0;
                    }

                    // If movement was extremely small, treat it as stuck and increment counter
                    const movedDist = Math.sqrt((e.x - prevX)*(e.x - prevX) + (e.y - prevY)*(e.y - prevY));
                    if (movedDist < 0.6) {
                        e.stuckCounter = (e.stuckCounter || 0) + 1;
                        
                        // If stuck for a while, respawn nearby instead of waiting for teleport
                        if (e.stuckCounter > 40) { // ~0.67 seconds at 60fps
                            let respawned = false;
                            // Try to find a safe spot within 200-400px radius
                            for (let attempt = 0; attempt < 50; attempt++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 200 + Math.random() * 200; // 200-400px away
                                const nx = e.x + Math.cos(angle) * distance;
                                const ny = e.y + Math.sin(angle) * distance;
                                
                                // Check bounds and collision
                                if (nx > CONFIG.radius && nx < CONFIG.worldW - CONFIG.radius &&
                                    ny > CONFIG.radius && ny < CONFIG.worldH - CONFIG.radius &&
                                    !checkCollide(nx, ny)) {
                                    e.x = nx;
                                    e.y = ny;
                                    e.stuckCounter = 0;
                                    e.mode = 'PATROL';
                                    e.targetX = Math.random() * (CONFIG.worldW - 100) + 50;
                                    e.targetY = Math.random() * (CONFIG.worldH - 100) + 50;
                                    respawned = true;
                                    break;
                                }
                            }
                            
                            // Fallback: if nearby respawn failed, try anywhere
                            if (!respawned) {
                                for (let attempt = 0; attempt < 50; attempt++) {
                                    const nx = Math.random() * (CONFIG.worldW - 200) + 100;
                                    const ny = Math.random() * (CONFIG.worldH - 200) + 100;
                                    if (!checkCollide(nx, ny)) {
                                        e.x = nx;
                                        e.y = ny;
                                        e.stuckCounter = 0;
                                        e.mode = 'PATROL';
                                        e.targetX = Math.random() * (CONFIG.worldW - 100) + 50;
                                        e.targetY = Math.random() * (CONFIG.worldH - 100) + 50;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        e.stuckCounter = 0;
                    }
                }

                // 잡힘 판정
                if (dist < CONFIG.radius * 2) {
                    gameOver(e);
                }
            });
        }

        function draw() {
            // 카메라
            const cx = window.innerWidth/2 - state.player.x;
            const cy = window.innerHeight/2 - state.player.y;
            els.world.style.transform = `translate3d(${cx}px, ${cy}px, 0)`;

            // 플레이어
            els.player.style.transform = `translate(${state.player.x}px, ${state.player.y}px) rotate(${state.player.angle}rad)`;

            // 사감들
            state.enemies.forEach(e => {
                e.el.style.transform = `translate(${e.x}px, ${e.y}px) rotate(${e.angle}rad)`;
                // Fog of War: 사감 숨기기
                const visible = hasLineOfSight(state.player, e);
                e.el.style.opacity = visible ? 1 : 0;
                e.isVisible = visible; // 시야 렌더링용 플래그 저장
            });

            // UI
            els.score.innerText = state.score.toLocaleString();
            els.combo.innerText = `COMBO x${state.combo}`;
            els.combo.style.opacity = state.combo > 1 ? 1 : 0;

            // 시야 그리기
            const ctx = els.ctx;
            ctx.clearRect(0, 0, CONFIG.worldW, CONFIG.worldH);

            state.enemies.forEach(e => {
                // 버그 수정: 사감이 플레이어 눈에 안 보이면 빨간 시야도 안 그림
                if (!e.isVisible) return; 

                const rays = 30;
                const viewAngle = e.data.angle * Math.PI / 180;
                const startAngle = e.angle - viewAngle/2;
                const step = viewAngle / rays;

                ctx.fillStyle = e.type === 'king' ? "rgba(165, 94, 234, 0.3)" : "rgba(255, 71, 87, 0.3)";
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);

                for(let i=0; i<=rays; i++) {
                    const ang = startAngle + step * i;
                    const rayEnd = { x: e.x + Math.cos(ang)*e.data.view, y: e.y + Math.sin(ang)*e.data.view };
                    
                    let closest = rayEnd;
                    let minT = 1.0;

                    for(let o of state.obstacles) {
                        const walls = [
                            {s:{x:o.x, y:o.y}, e:{x:o.x+o.w, y:o.y}},
                            {s:{x:o.x+o.w, y:o.y}, e:{x:o.x+o.w, y:o.y+o.h}},
                            {s:{x:o.x+o.w, y:o.y+o.h}, e:{x:o.x, y:o.y+o.h}},
                            {s:{x:o.x, y:o.y+o.h}, e:{x:o.x, y:o.y}}
                        ];
                        for(let w of walls) {
                            const isect = getIntersection(e, rayEnd, w.s, w.e);
                            if(isect && isect.param < minT) { minT = isect.param; closest = isect; }
                        }
                    }
                    ctx.lineTo(closest.x, closest.y);
                }
                ctx.closePath();
                ctx.fill();
            });
        }

        function loop() {
            if(!state.running) return;
            update();
            draw();
            state.animId = requestAnimationFrame(loop);
        }

        function gameOver(killer) {
            state.running = false;
            cancelAnimationFrame(state.animId);
            els.overlay.classList.remove('hidden');
            document.getElementById('title-text').innerText = "검거됨";
            
            // 엔딩 메시지
            els.endMsg.innerText = `"${killer.data.msg}"`;
            els.endMsg.style.color = killer.type === 'king' ? '#a55eea' : '#ff4757';
            
            els.btn.innerText = "다시 도전";
        }

        // --- 실행 ---
        els.btn.addEventListener('click', () => {
            if(state.animId) cancelAnimationFrame(state.animId);
            
            // 적 제거
            state.enemies.forEach(e => e.el.remove());
            state.enemies = [];

            generateMap();
            state.running = true;
            state.score = 0;
            state.combo = 1;
            state.gameTime = 0;
            // 안전한 위치로 스폰 (책상에 끼이지 않도록)
            const spawn = findSafeSpawn();
            state.player = { x: spawn.x, y: spawn.y, angle: 0, stunned: 0 };
            
            // 1학년 사감 생성
            spawnEnemy('1yr');

            els.overlay.classList.add('hidden');
            loop();
        });

        window.addEventListener('keydown', e => state.keys[e.code] = true);
        window.addEventListener('keyup', e => state.keys[e.code] = false);
    </script>
</body>
</html>
